//module 7
//(optimised to fit into two blocks)

//exception handler routine
loadi(2, 15);
loadi(3, 16);

//timer interrupt routine
loadi(4, 17);
loadi(5, 18);

//disk interrupt handler
loadi(6, 19);
loadi(7, 20);

//console interrupt handler
loadi(8, 21);
loadi(9, 22);

//library Code
loadi(63, 13);
loadi(64, 14);

//int 4
loadi(10, 23);
loadi(11, 24);

//int 5
loadi(12, 25);
loadi(13, 26);

//int 6
loadi(14, 27);
loadi(15, 28);

//int 7
loadi(16, 29);
loadi(17, 30);

//int 8
loadi(18, 31);
loadi(19, 32);

//int 9
loadi(20, 33);
loadi(21, 34);

//int 10
loadi(22, 35);
loadi(23, 36);

//int 11
loadi(24, 37);
loadi(25, 38);

//int 12
loadi(26, 39);
loadi(27, 40);

//int 13
loadi(28, 41);
loadi(29, 42);

//int 14
loadi(30, 43);
loadi(31, 44);

//int 15
loadi(32, 45);
loadi(33, 46);

//int 16
loadi(34, 47);
loadi(35, 48);

//int 17
loadi(36, 49);
loadi(37, 50);

//resource manager module (module 0)
loadi(40,53);
loadi(41,54);

//process manager module (module 1)
loadi(42, 55);
loadi(43, 56);

//memory manager module (module 2)
loadi(44, 57);
loadi(45, 58);

//file manager module (module 3)
loadi(46, 59);
loadi(47, 60);

//device manager module (module 4)
loadi(48,61);
loadi(49,62);

//scheduler module (module 5)
loadi(50,63);
loadi(51,64);

// pager module (module 6)
loadi(52,65);
loadi(53,66);

//disk free list
loadi(61, 2);

//root file
loadi(62, 5);

//inode table + user table
loadi(59, 3);
loadi(60, 4);

//init(login) program
loadi(65, 7);

//shell program
loadi(67, 9);
loadi(68, 10);

alias processTableValue R0;
alias pageTableValue R1;

//setup init(login) process
processTableValue = PROCESS_TABLE + 16;
pageTableValue = PAGE_TABLE_BASE + 20;

[processTableValue + 0] = 0;
[processTableValue + 1] = LOGIN_PROCESS;
[processTableValue + 3] = ROOT;
[processTableValue + 4] = CREATED;
[processTableValue + 11] = 77;
[processTableValue + 12] = 0;
[processTableValue + 13] = 8*PAGE_SIZE;
[processTableValue + 14] = pageTableValue;
[processTableValue + 15] = 10;

//Library
[pageTableValue] = 63;
[pageTableValue + 1] = "0100";
inline "ADD R1, 2";
[pageTableValue] = 64;
[pageTableValue + 1] = "0100";
inline "ADD R1, 2";
//Heap
[pageTableValue] = -1;
[pageTableValue+ 1] = "0000";
inline "ADD R1, 2";
[pageTableValue] = -1;
[pageTableValue+ 1] = "0000";
inline "ADD R1, 2";
//Code
[pageTableValue] = 65;
[pageTableValue+ 1] = "0100";
inline "ADD R1, 2";
[pageTableValue] = -1;
[pageTableValue+ 1] = "0000";
inline "ADD R1, 2";
[pageTableValue] = -1;
[pageTableValue+ 1] = "0000";
inline "ADD R1, 2";
[pageTableValue] = -1;
[pageTableValue+ 1] = "0000";
inline "ADD R1, 2";
//Stack
[pageTableValue] = 66;
[pageTableValue+ 1] = "0110";
inline "ADD R1, 2";
[pageTableValue] = -1;
[pageTableValue+ 1] = "0000";
inline "ADD R1, 2";
//entry point
[66*PAGE_SIZE] = [65*PAGE_SIZE + 1];

//per process resource table
alias procResTableInd R2;
procResTableInd = 0;
while(procResTableInd < 8) do
	[(77*PAGE_SIZE) + RESOURCE_TABLE_OFFSET + (procResTableInd*2)] = -1;
	procResTableInd = procResTableInd + 1;
endwhile;


//setup shell process
processTableValue = PROCESS_TABLE + 16*SHELL_PROCESS;
pageTableValue = PAGE_TABLE_BASE + 20*SHELL_PROCESS;

[processTableValue + 0] = 0;
[processTableValue + 1] = SHELL_PROCESS;
[processTableValue + 2] = LOGIN_PROCESS;		//ppid
[processTableValue + 3] = ROOT;
[processTableValue + 4] = TERMINATED;		//will be 'created' after login
[processTableValue + 11] = 80;
[processTableValue + 12] = 0;
[processTableValue + 13] = 8*PAGE_SIZE;
[processTableValue + 14] = pageTableValue;
[processTableValue + 15] = 10;

//Library
[pageTableValue] = 63;
[pageTableValue + 1] = "0100";
inline "ADD R1, 2";
[pageTableValue] = 64;
[pageTableValue + 1] = "0100";
inline "ADD R1, 2";
//Heap
[pageTableValue] = -1;
[pageTableValue + 1] = "0000";
inline "ADD R1, 2";
[pageTableValue] = -1;
[pageTableValue + 1] = "0000";
inline "ADD R1, 2";
//Code
[pageTableValue] = 67;
[pageTableValue + 1] = "0100";
inline "ADD R1, 2";
[pageTableValue] = 68;
[pageTableValue + 1] = "0100";
inline "ADD R1, 2";
[pageTableValue] = -1;
[pageTableValue + 1] = "0000";
inline "ADD R1, 2";
[pageTableValue] = -1;
[pageTableValue + 1] = "0000";
inline "ADD R1, 2";
//Stack
[pageTableValue] = 78;
[pageTableValue + 1] = "0110";
inline "ADD R1, 2";
[pageTableValue] = 79;
[pageTableValue + 1] = "0110";
inline "ADD R1, 2";
//entry point
[78*PAGE_SIZE] = [67*PAGE_SIZE + 1];

//per process disk map table
alias diskMapTableEntry R2;
diskMapTableEntry = DISK_MAP_TABLE + 10*SHELL_PROCESS;
[diskMapTableEntry + 2] = -1;
[diskMapTableEntry + 3] = -1;
[diskMapTableEntry + 4] = 9;		//code block 1
[diskMapTableEntry + 5] = 10;		//code block 2
[diskMapTableEntry + 6] = -1;
[diskMapTableEntry + 7] = -1;
[diskMapTableEntry + 8] = -1;
[diskMapTableEntry + 9] = -1;

//per process resource table
alias procResTableInd R2;
procResTableInd = 0;
while(procResTableInd < 8) do
	[(80*PAGE_SIZE) + RESOURCE_TABLE_OFFSET + (procResTableInd*2)] = -1;
	inline "ADD R2, 1";
endwhile;


alias procId R2;
procId = SHELL_PROCESS + 1;
while (procId < SWAPPER_DAEMON) do
	R3 = PROCESS_TABLE + 16*procId;
	[R3 + 0] = 0;
	[R3 + 4] = TERMINATED;
	inline "ADD R2, 1";
endwhile; 


[TERMINAL_STATUS_TABLE] = 0;
[DISK_STATUS_TABLE] = 0;


//Initialize the memory free list with value 1 for pages used and 0 for free pages.
alias memPage R2;
memPage = 0;
//0-75 are reserved. 76-82 are used for the init, shell, swapper daemon processes.
while(memPage <= 82) do
	[MEMORY_FREE_LIST + memPage] = 1;
	inline "ADD R2, 1";
endwhile;
while(memPage < MAX_MEM_PAGE) do
	[MEMORY_FREE_LIST + memPage] = 0;
	inline "ADD R2, 1";
endwhile;


[SYSTEM_STATUS_TABLE + 2] = 45;							//mem free count
[SYSTEM_STATUS_TABLE + 3] = 0;							//wait mem count
[SYSTEM_STATUS_TABLE + 4] = 0;							//swapped count
[SYSTEM_STATUS_TABLE + 5] = 0;							//paging status


//page tables and disk map tables need not be initalized since they'll be copied over while forking

//Initialize the semaphore table
alias semIndex R2;
semIndex = 0;
while(semIndex < MAX_SEM_COUNT) do
	R3 = SEMAPHORE_TABLE + 4*semIndex;
	[R3] = -1;			//locking pid
	[R3 + 1] = 0;		//process count
	inline "ADD R2, 1";
endwhile;

//Initialize file status table
alias fileIndex R2;
fileIndex = 0;
while(fileIndex < MAX_FILE_NUM) do
	R3 = FILE_STATUS_TABLE + 4*fileIndex;
	[R3] = -1;			//locking pid
	[R3 + 1] = -1;	//file open count
	inline "ADD R2, 1";
endwhile;

//Initialize buffer table
alias bufferIndex R2;
bufferIndex = 0;
while(bufferIndex < MAX_BUFFER) do
	R3 = BUFFER_TABLE + 4*bufferIndex;
	[R3] = -1;			//block number
	[R3 + 1] = 0;		//dirty bit
	[R3 + 2] = -1;	//locking pid
	inline "ADD R2, 1";
endwhile;

//Initialize open file table
alias openIndex R2;
openIndex = 0;
while(openIndex < MAX_OPENFILE_NUM) do
	R3 = OPEN_FILE_TABLE + 4*openIndex;
	[R3] = -1;				//inode index
	[R3 + 1] = 0;		//open instance count
	inline "ADD R2, 1";
endwhile;

return;