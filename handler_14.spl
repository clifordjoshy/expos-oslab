//semlock, semunlock

alias systemCallNum R0;
systemCallNum = [([PTBR + 2 * ((SP-5)/PAGE_SIZE)] * PAGE_SIZE) + ((SP-5) % PAGE_SIZE)];

//mode flag
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1] * 16 + 9] = systemCallNum;

alias userSP R1;
userSP = SP;

[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 5*CORE + 1] * 16) + 13] = SP;

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 5*CORE + 1] * 16) + 11] * PAGE_SIZE - 1;


//semId is the index of the semaphore in the per process resource table
//semIndex is the index of the semaphore in the semaphore table

if(systemCallNum == INT_SEMLOCK) then
	alias semId R2;
	semId = [([PTBR + 2*((userSP-4)/PAGE_SIZE)] * PAGE_SIZE) + ((userSP-4) % PAGE_SIZE)];

	alias resTable R3;
	resTable = [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 5*CORE + 1] + 11] * PAGE_SIZE + RESOURCE_TABLE_OFFSET;
	
	if(semId < 0 || semId > 7 || [resTable + 2*semId] != SEMAPHORE) then
		[([PTBR + 2*((userSP-1)/PAGE_SIZE)] * PAGE_SIZE) + ((userSP-1) % PAGE_SIZE)] = -1;
		[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16 + 9] = 0;
		SP = userSP;
		ireturn;
	endif;

	alias currentPID R4;
	currentPID = [SYSTEM_STATUS_TABLE + 5*CORE + 1];

	alias semIndex R5;
	semIndex = [resTable + 2*semId + 1];

	while([SEMAPHORE_TABLE + 4*semIndex] != -1 && [SEMAPHORE_TABLE + 4*semIndex] != currentPID) do
		[PROCESS_TABLE + 16*currentPID + 4] = WAIT_SEMAPHORE;
		[PROCESS_TABLE + 16*currentPID + 5] = semIndex;
		multipush(R0, R1, R2, R3, R4, R5);
		call CONTEXT_SWITCH;
		multipop(R0, R1, R2, R3, R4, R5);
	endwhile;

	[SEMAPHORE_TABLE + 4*semIndex] = currentPID;

	[([PTBR + 2*((userSP-1)/PAGE_SIZE)] * PAGE_SIZE) + ((userSP-1) % PAGE_SIZE)] = 0;
endif;


if(systemCallNum == INT_SEMUNLOCK) then
	alias semId R2;
	semId = [([PTBR + 2*((userSP-4)/PAGE_SIZE)] * PAGE_SIZE) + ((userSP-4) % PAGE_SIZE)];

	alias resTable R3;
	resTable = [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 5*CORE + 1] + 11] * PAGE_SIZE + RESOURCE_TABLE_OFFSET;

	if(semId < 0 || semId > 7 || [resTable + 2*semId] != SEMAPHORE) then
		[([PTBR + 2*((userSP-1)/PAGE_SIZE)] * PAGE_SIZE) + ((userSP-1) % PAGE_SIZE)] = -1;
		[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16 + 9] = 0;
		SP = userSP;
		ireturn;
	endif;

	alias semIndex R4;
	semIndex = [resTable + 2*semId + 1];

	//if is locked
	if([SEMAPHORE_TABLE + 4*semIndex] != -1) then

		//not current process
		if([SEMAPHORE_TABLE + 4*semIndex] != [SYSTEM_STATUS_TABLE + 5*CORE + 1]) then
			[([PTBR + 2*((userSP-1)/PAGE_SIZE)] * PAGE_SIZE) + ((userSP-1) % PAGE_SIZE)] = -2;
			[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1]*16 + 9] = 0;
			SP = userSP;
			ireturn;
		endif;

		[SEMAPHORE_TABLE + 4*semIndex] = -1;

		alias procId R5;
		procId = 0;
		while (procId < MAX_PROC_NUM) do
			if([PROCESS_TABLE + 16*procId + 4] == WAIT_SEMAPHORE && [PROCESS_TABLE + 16*procId + 5] == semIndex) then
				[PROCESS_TABLE + 16*procId + 4] = READY;
			endif;

			procId = procId + 1;
		endwhile;

	endif;

	[([PTBR + 2*((userSP-1)/PAGE_SIZE)] * PAGE_SIZE) + ((userSP-1) % PAGE_SIZE)] = 0;
endif;


[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1] * 16 + 9] = 0;
SP = userSP;
ireturn;